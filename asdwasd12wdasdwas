--[[
    Optimized Event Automation Script for Pet Simulator 99
    =======================================================
    Features:
      1. Joins the event automatically.
      2. Farms breakables and hatches the egg for 10 minutes.
      3. After farming, enters auto raid mode:
           - Creates/joins a solo raid at the best difficulty.
           - After a configurable number of raids, returns to farming mode.
      4. Runs auto event upgrades in the background using a configurable list.
      5. Auto crafts clovers into lucky gifts (if enabled).
      6. Uses fast autofarm + auto tap while minimizing CPU/ram usage.
      7. Auto uses best potions/fruits when available and auto uses ultimate.
      
    Adjust the configuration variables below as needed.
--]]

----------------------------
-- CONFIGURATION ----------
----------------------------
local CONFIG = {
    FARM_TIME = 600,         -- seconds of farming/hatching (10 minutes)
    RAID_THRESHOLD = 999,      -- number of raids to complete before returning to farming
    UPGRADES = {             -- list of upgrades to purchase continuously
        "AutumnMoreEggLuck",
        "AutumnMoreBossDamage",
        "LuckyRaidPets",
        "LuckyRaidDamage",
        "LuckyRaidAttackSpeed",
        "LuckyRaidPetSpeed",
        "LuckyRaidEggCost",
        "LuckyRaidMoreCurrency",
        "LuckyRaidXP",
        "LuckyRaidBetterLoot",
        "LuckyRaidHugeChest",
        "LuckyRaidTitanicChest"
    },
    AUTO_CRAFT_CLOVERS = true,   -- set to true to auto craft clovers into lucky gifts
}

----------------------------
-- INITIALIZATION & SETUP --
----------------------------
while not game:IsLoaded() do task.wait() end
task.wait(3)
local wrk = game:GetService("Workspace")
local rep = game:GetService("ReplicatedStorage")
local plrs = game:GetService("Players")
local lp = plrs.LocalPlayer

-- Disable unnecessary animations for performance (egg animation)
local animBruh = lp.PlayerScripts.Scripts.Game['Egg Opening Frontend']
getsenv(animBruh).PlayEggAnimation = function() end

local network = rep:WaitForChild("Network", 5)
local client = rep.Library.Client
local quests = require(rep.Library.Types.Quests)  -- still required for some functions
local firstEgg = Vector3.new(784.9210815429688, 19.35114860534668, -22484.810546875)

-- Disable 3D rendering and hide GUIs to reduce CPU/ram usage
if game:GetService("RunService").Set3dRenderingEnabled then
    game:GetService("RunService"):Set3dRenderingEnabled(false)
end
for _, gui in pairs(game:GetService("CoreGui"):GetChildren()) do
    gui:Destroy()
end
for _, v in pairs(lp.PlayerGui:GetDescendants()) do
    if v:IsA("Frame") then v.Visible = false end
end

-- Prevent idle kick
local VirtualUser = game:GetService("VirtualUser")
lp.Idled:Connect(function()
    VirtualUser:Button2Down(Vector2.new(0,0), wrk.CurrentCamera.CFrame)
    task.wait(1)
    VirtualUser:Button2Up(Vector2.new(0,0), wrk.CurrentCamera.CFrame)
end)

----------------------------
-- CORE UTILITY FUNCTIONS --
----------------------------
local function getClosestPointOnPart(part, targetPosition)
    local partCFrame = part.CFrame
    local partSize = part.Size
    local localTargetPosition = partCFrame:PointToObjectSpace(targetPosition)
    local halfSize = partSize * 0.5
    local clampedX = math.clamp(localTargetPosition.X, -halfSize.X, halfSize.X)
    local clampedY = math.clamp(localTargetPosition.Y, -halfSize.Y, halfSize.Y)
    local clampedZ = math.clamp(localTargetPosition.Z, -halfSize.Z, halfSize.Z)
    local clampedLocalPosition = Vector3.new(clampedX, clampedY, clampedZ)
    return partCFrame:PointToWorldSpace(clampedLocalPosition)
end

local function getLpData()
    local data = require(client.Save).GetSaves()
    return data[lp]
end

local function tp(cf)
    pcall(function()
        local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
        if hrp and (hrp.Position - cf.Position).Magnitude > 5 then
            hrp.CFrame = cf
        end
    end)
end

----------------------------
-- EVENT JOINING ----------
----------------------------
local function joinEvent()
    local args = { { ["3261"] = "11130" } }
    local joinRemote = rep:WaitForChild("Network"):WaitForChild("Breakables_JoinPetBulk")
    joinRemote:FireServer(unpack(args))
    -- Teleport to event entry point
    tp(wrk["__THINGS"].Instances.AutumnEvent.Teleports.Enter.CFrame)
    task.wait(3)
end

joinEvent()

----------------------------
-- EGG & BREAKABLE FUNCTIONS --
----------------------------
local function getClosestEgg(pos)
    local eggs = wrk["__THINGS"].CustomEggs
    local closest = {egg = nil, dist = math.huge}
    for _, v in next, eggs:GetChildren() do
        if v:IsA("Model") and v.PrimaryPart then
            local dist = (v.PrimaryPart.Position - pos).Magnitude
            if dist < closest.dist then
                closest.egg = v
                closest.dist = dist
            end
        end
    end
    return closest.egg
end

-- Farms breakables by having pets hit them (using realistic clicks)
local function petTargetChestAndBreakables()
    local function findChest()
        for _, v in pairs(wrk["__THINGS"].Breakables:GetChildren()) do
            if v:FindFirstChild("Top") then
                return tonumber(v.Name)
            end
        end
    end

    local function findNormal()
        local normal = {}
        for _, v in pairs(wrk["__THINGS"].Breakables:GetChildren()) do
            if v:FindFirstChild("1") or v:FindFirstChild("2") or v:FindFirstChild("3") then
                table.insert(normal, tonumber(v.Name))
            end
        end
        return normal
    end

    local function findFruitCrate()
        for _, v in pairs(wrk["__THINGS"].Breakables:GetChildren()) do
            if v:FindFirstChild("Apple") or v:FindFirstChild("Banana") or v:FindFirstChild("Pineapple") then
                return tonumber(v.Name)
            end
        end
    end

    local function findAutChest()
        for _, v in pairs(wrk["__THINGS"].Breakables:GetChildren()) do
            if v:GetAttribute("BreakableID") == "AutumnChest" then
                -- Simulate realistic tap
                calculateRealisticClick(v.PrimaryPart.Position)
                return tonumber(v.Name)
            end
        end
    end

    local chestNum = findChest()
    local fruitCrateNum, normal
    if not chestNum then
        fruitCrateNum = findFruitCrate()
    end
    if not chestNum or not fruitCrateNum then
        normal = findNormal()
    end
    local foundChest = findAutChest()
    if foundChest then chestNum = foundChest end
    local normalIndex = 0
    local args = { [1] = {} }
    local obj
    for petId, _ in pairs(require(rep.Library.Client.PlayerPet).GetAll()) do
        normalIndex = normalIndex + 1
        if chestNum then 
            args[1][petId] = chestNum
            obj = chestNum
            rep.Library.Signal.Breakables_HitAnimation:Fire(tostring(obj))
        elseif fruitCrateNum then
            args[1][petId] = fruitCrateNum
            obj = fruitCrateNum
            rep.Library.Signal.Breakables_HitAnimation:Fire(tostring(obj))
        else
            pcall(function()
                args[1][petId] = normal[normalIndex]
                obj = normal[normalIndex]
                rep.Library.Signal.Breakables_HitAnimation:Fire(tostring(obj))
            end)
        end
    end
    network:WaitForChild("Breakables_JoinPetBulk"):FireServer(unpack(args))
end

-- Simulate realistic click for auto tap
local function calculateRealisticClick(targetPosition)
    local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end
    local function addNoise(value, magnitude)
        return value + (math.random() - 0.5) * magnitude
    end
    local direction = (targetPosition - hrp.Position).Unit
    direction = Vector3.new(addNoise(direction.X, 0.01), addNoise(direction.Y, 0.01), addNoise(direction.Z, 0.01)).Unit
    local rayOrigin = Vector3.new(addNoise(hrp.Position.X, 0.1), addNoise(hrp.Position.Y + 2, 0.1), addNoise(hrp.Position.Z, 0.1))
    local ray = Ray.new(rayOrigin, direction)
    local targetVector = Vector3.new(addNoise(targetPosition.X, 0.1), addNoise(targetPosition.Y, 0.1), addNoise(targetPosition.Z, 0.1))
    rep.Network.Click:FireServer(ray, targetVector)
end

-- Auto collect orbs and loot
local function collect()
    local things = wrk["__THINGS"]
    local orbs = {}
    for _, v in pairs(things.Orbs:GetChildren()) do
        table.insert(orbs, tonumber(v.Name))
        v:Destroy()
    end
    network:FindFirstChild("Orbs: Collect"):FireServer(orbs)
    for _, v in pairs(things.Lootbags:GetChildren()) do
        network.Lootbags_Claim:FireServer({tostring(v)})
        v:Destroy()
    end
end

----------------------------
-- AUTO USAGE FUNCTIONS ----
----------------------------
-- Auto use best potions/fruits (names are examples; adjust as needed)
local function usePotionsAndFruits()
    local items = getItemsByName("potion")  -- Adjust keyword as needed
    local fruits = getItemsByName("fruit")    -- Adjust keyword as needed
    local buff = getLpData().Buffs or {}
    local potionEvent = network:FindFirstChild("Potions_Consume")
    local fruitEvent = network:FindFirstChild("Fruits_Consume")
    if potionEvent and items["Best Potion"] and not buff["Best Potion"] then
        potionEvent:InvokeServer()
    end
    if fruitEvent and fruits["Best Fruit"] and not buff["Best Fruit"] then
        fruitEvent:InvokeServer()
    end
end

-- Auto use ultimate periodically
local function useUlt()
    local ult = nil
    local lpData = getLpData()
    if lpData then
        local equippedUlt = lpData.EquippedUltimate
        if equippedUlt then
            ult = lpData.Inventory.Ultimate[equippedUlt].id
        end
    end
    if ult then
        network["Ultimates: Activate"]:InvokeServer(ult)
    end
    task.wait(10)
end

----------------------------
-- AUTO UPGRADES & CRAFTING -
----------------------------
-- Continuously purchase event upgrades from the config
local function autoEventUpgrades()
    while true do
        for _, upgrade in ipairs(CONFIG.UPGRADES) do
            pcall(function()
                network["EventUpgrades: Purchase"]:InvokeServer(upgrade)
            end)
        end
        task.wait(5)
    end
end
task.spawn(autoEventUpgrades)

-- Auto craft clovers into lucky gifts (pseudo-code; adjust remote/event names as needed)
local function autoCraftClovers()
    while CONFIG.AUTO_CRAFT_CLOVERS do
        local items = getItemsByName("Clover")
        if items["Clover"] and items["Clover"].amnt and items["Clover"].amnt >= 10 then
            pcall(function()
                network["CraftLuckyGift"]:InvokeServer()  -- Replace with actual remote if available
            end)
        end
        task.wait(10)
    end
end
if CONFIG.AUTO_CRAFT_CLOVERS then
    task.spawn(autoCraftClovers)
end

-- Auto use potions/fruits and ultimate in the background
task.spawn(function()
    while true do
        usePotionsAndFruits()
        useUlt()
        task.wait(5)
    end
end)

----------------------------
-- MAIN MODE FUNCTIONS ------
----------------------------
-- Farming mode: farms breakables and continuously hatches egg for CONFIG.FARM_TIME seconds.
local function farmAndHatch()
    local startTime = tick()
    while tick() - startTime < CONFIG.FARM_TIME do
        -- Auto-farm breakables
        petTargetChestAndBreakables()
        -- Hatch egg continuously
        local hrp = lp.Character and lp.Character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local egg = getClosestEgg(hrp.Position)
            if egg then
                local eggCount = getLpData().EggHatchCount or 1
                network.CustomEggs_Hatch:InvokeServer(tostring(egg), eggCount)
            end
        end
        collect()
        task.wait(3)  -- adjust wait for balance between speed and CPU usage
    end
end

-- Raid mode: repeatedly creates and joins a solo raid until the raid threshold is met.
local function executeRaidCycle()
    local raidCounter = 0
    while raidCounter < CONFIG.RAID_THRESHOLD do
        -- Create and join a solo raid at best difficulty.
        local raidArgs = {
            [1] = {
                ["Difficulty"] = 14,  -- adjust as needed for best difficulty
                ["Portal"] = 3,       -- chosen free portal
                ["PartyMode"] = 1     -- solo mode
            }
        }
        network:WaitForChild("Raids_RequestCreate"):InvokeServer(unpack(raidArgs))
        task.wait(0.5)
        network:WaitForChild("Raids_Join"):InvokeServer(3)
        raidCounter = raidCounter + 1
        task.wait(2)
    end
end

----------------------------
-- MAIN LOOP --------------
----------------------------
while true do
    -- Farming mode for 10 minutes
    farmAndHatch()
    -- Then switch to raid mode for a set number of raids
    executeRaidCycle()
    -- After raids, loop back to farming mode
    task.wait(2)
end
